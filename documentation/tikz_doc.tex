\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}
\usepackage[margin=2cm]{geometry}

\setlength\parindent{0pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{litmus, litmus.listings}
\litmusset{use listing={style=litmus, basicstyle=\footnotesize\ttfamily}}

% change listings colors:
% \colorlet{barrier color}{black}
% \colorlet{brunch color}{black}
% \colorlet{memory color}{black}
% \colorlet{register color}{black}

\newcommand{\TikZ}{Ti\textit{k}Z}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tcolorbox}
\tcbuselibrary{listings}
\tcbuselibrary{skins}

\lstset{
  language={[LaTeX]TeX},
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\color{black!75},
  columns=flexible,
  keepspaces=true,
}

\tcbset{
  listing options={
      language={[LaTeX]TeX},
      basicstyle=\footnotesize\ttfamily,
      commentstyle=\color{black!75},
      columns=flexible,
      keepspaces=true,
  },
  frame hidden,
  sharp corners,
  bicolor,
  top=0pt,
  bottom=0pt,
  left=0pt,
  right=0pt,
  colback=blue!10,
  colbacklower=white,
  sidebyside align=top seam,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{hyperref}
\hypersetup{
    linkbordercolor={1 1 1},
    colorlinks=true,
    linkcolor=violet,
%     citebordercolor={0.5 1 0.5},
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\section{Introduction}

\verb|litmus| is a \TikZ{} library for typesetting litmus test diagrams.
It supports hand written diagrams and diagrams generated by the
\texttt{rmem} tool (the former being slightly easier for humans to read
and write).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Minimal examples}
\tcbinputlisting{listing only, listing file=minimal.tex}

The examples in this document make use of \verb|<litmus>.tikz| and
\verb|<litmus>.states.tex| files that \texttt{rmem} generates. See the
included \verb|Makefile| as to how to generate those files.
\verb|<litmus>.tikz| is a \TikZ{} picture, and it can be used by
invoking one of the input macros described in the next section
(\S\ref{sec:inputs}, \nameref{sec:inputs}) as in the example above, or
by simply wrapping it with a \lstinline|tikzpicture| environment:
\begin{tcblisting}{listing only}%{sidebyside, lefthand width=8.5cm}
\begin{tikzpicture}[/litmus/kind=events,/litmus/AArch64]
  \input{A64/MP+dmb.sy+ctrl.tikz}
\end{tikzpicture}
\end{tcblisting}
\vspace{2ex}

\verb|<litmus>.states.tex| defines the macros \lstinline+\litmusname+,
\lstinline+\litmusarch+, \lstinline+\initstate+ and \lstinline+\finalstate+
that the \lstinline+\inputlitmustable+ macro uses.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Input a .tikz file}\label{sec:inputs}

Inputting a \verb|<litmus>.tikz| file that was generated by \texttt{rmem}:
\begin{tcblisting}{listing only}
\inputlitmuspicture[<options>]{<kind>}{<.tikz file>} % WITHOUT the .tikz suffix
  % input the .tikz file wrapped in a tikzpicture environment with '[/litmus/kind=<kind>, <options>]'

\inputlitmus[<options>]{<kind>}{<.tikz file>} % WITHOUT the .tikz suffix
  % to be used inside a tikzpicture environment;
  % input the .tikz file wrapped in a scope environment with '[/litmus/kind=<kind>, <options>]'

\inputlitmustable[<options>]{<kind>}{<.tikz file>} % WITHOUT the .tikz suffix
  % input the .tikz file and a .states.tex file wrapped in a litmus test table

\end{tcblisting}

The \lstinline|<kind>| argument can be one of:
\begin{itemize}\itemsep0ex
  \item[] \lstinline|full| - typeset a diagram with assembly code and memory events;
  \item[] \lstinline|events| - typeset a diagram of memory events; or
  \item[] \lstinline|assem| - typeset the assembly code.
\end{itemize}

The following section describes the different things that can be provided, as
a comma separated list, in the \lstinline|<options>| argument.

\section{Options}

All the options below (which are just regular pgf keys) have the path
\lstinline|/litmus/<option>|.
Hence to globally set the \lstinline|non-mixed-size| option, for example,
one has to call \lstinline+\tikzset{/litmus/non-mixed-size}+.
Since \lstinline|/litmus| is set to be a key-family, you can also use
\lstinline+\tikzset{/litmus,<options>}+, here \lstinline|/litmus| changes the
default path to \lstinline|/litmus/|, so \lstinline|<options>| do not need to include
this path for every option.
The macro \lstinline+\litmusset{<options>}+ is the same as doing
\lstinline+\tikzset{/litmus,<options>}+, which is the same as doing
\lstinline+\pgfkeys{/litmus,<options>}+.

When the default path is \lstinline|/litmus| and an unknown key is
encountered, the key is also search under the \lstinline|/tikz| path.

When the macros from \S\ref{sec:inputs} evaluate \lstinline|<options>| they
first set the default path to \lstinline|/litmus/| so it can be omitted
from the options.
Note that when you define \lstinline|<key>/.style={...}| the default path
inside the curly braces depends on the context in which the style is
used.
All the styles that are described below are used when \lstinline|/litmus/|
is the default path so it can be omitted from the keys there too.

When writing a diagram by hand, the default path for the options of
\lstinline|\node|, \lstinline|\path|, \lstinline|edge| etc.\ is always \lstinline|/tikz|
and there is no simple way of changing it globally.
Hence, you will have to prefix all the options with \lstinline|/litmus/| which
is annoying.
The \lstinline|litmus| library defines the key
\lstinline|/litmus/append to tikz path search| so that when it is called the
way unknown keys in the \lstinline|/tikz| path are handled is changed, inside
the current \TeX{} group, to also search for the unknown key in the
\lstinline|/litmus| path.
Therefore, after using the key \lstinline|/litmus/append to tikz path search|
in the options of a \lstinline|tikzpicture| environment, you can use
\lstinline|/litmus| options anywhere within the picture environment without
the \lstinline|/litmus/| prefix.
Note that this is somewhat of a hack (the key redefines the pgf key
\lstinline|/errors/unknown key|), so it is better not to use it in global
settings (e.g. do not do \lstinline+\tikzset{/litmus/append to tikz path search}+
in the preamble) but it should be safe to use it per-\lstinline|tikzpicture|
environment.

\vspace{2cm}

Specify the architecture of the test:
\begin{tcblisting}{listing only}
base language % minimal definitions
AArch64
Power
RISCV
x86
every <arch>/.style={...}
  % where <arch> is one of the above architectures.
\end{tcblisting}

Specify a new architecture:
\begin{tcblisting}{listing only}
\litmusset={
  <arch>/.style={
    /litmus/listing options/.if defined=then {
      /litmus/listing options/.prefix={language=<arch>,}
    },
    /litmus/base language, % definitions for R, W, po, data, etc.
    % Memory access kinds as generated in pp.ml (pp_brief_write_kind
    % and pp_brief_read_kind):
    /litmus/mem access/<kind>/.code={...},% PP memory access <kind>
    % Edge labels as generated in tikz.ml
    /litmus/<edge>/.litmus relation=<color>,
    /litmus/.cd scope={every <arch>/.try},
  },
}
\end{tcblisting}


Typesetting footprints of memory accesses and \texttt{rf} edges:
\begin{tcblisting}{listing only}
non-mixed-size  % e.g. "a:W x=1" (this is the default)
mixed-size      % e.g. "a:W x[0..3]=1"
old-mixed-size  % e.g. "a:W x+4/2=1"

memfp/.code n args={3}{...} % (no default, initial value is set by the options above)
memrf/.code 2 args={...} % (no default, initial value is set by the options above)

is mixed-size/.if true=then {<true>}[ else {<false>}]
  % (It only makes sense to use this inside a style like 'every event')
  % Evaluates <true> when mixed-size or old-mixed-size are set,
  % otherwise evaluates <false>.
is mixed-size/.if false=then {<true>}[ else {<false>}]
\end{tcblisting}

\begin{tcblisting}{listing only}
threads distance=<dimension> % (no default, initially 3em (full/events) or 0 (assem))
header to instructions distance=<dimension> % (no default, initially 0.5ex (full/events) or 0 (assem))
every thread/.style={...} % #1 is set to tid
thread <tid>/.style={...}
add thread header=<true|false> % (default true, initially true)
  % This option, when given in one of the two styles above, determines
  % if the thread will have a header (e.g. "Thread 0") or not.
every thread header/.style={...} % #1 is set to tid
thread <tid> header/.style={...}
thread header text={...} % Typeset the thread header text
  % e.g. 'every thread header/.style={thread header text={Thread~#1}}'
\end{tcblisting}

\begin{tcblisting}{listing only}
every instructions/.style={...}
add row after={<ioid>}{<text>} % (no default)
  % can be used multiple times with the same ioid. The new lines are referenced with 'assem <ioid>-1',
  % 'assem <ioid>-2', ...

add space after row=<dimension>
  % For example:
  % every instructions/.style={
  %    /tikz/row 3/.style={/litmus/add space after row=4ex},
  % },
\end{tcblisting}
Note that \lstinline|instructions| is a \TikZ{} matrix and as such all the
regular matrix keys can be used to manipulate it. In particular the key
'row sep' can be used to change the space between the instructions. If
you set this key you probably want to use the 'between origins' keyword
to make the threads align properly.

\begin{tcblisting}{listing only}
compute assem text width={<unique name>} % (no default)
\end{tcblisting}
This will initially unset the \lstinline|text width| of all the assem instructions
and save the width of each assem instructions column to the .aux file.
In the next run of latex, if \lstinline|text width| was not set manually, the
\lstinline|text width| of all the assem instructions will be set to the saved
value.
In addition, the pgf math function
\lstinline+computedwidthofthread("<unique name>",<tid>)+ will expand
to the saved width of thread \lstinline|<tid>| of \lstinline|<unique name>|, and
\lstinline+computedwidthof("<unique name>")+ will expand to the saved
width of the thread in context of \lstinline|<unique name>|. Finally,
\lstinline+computedwidth+ will expand to the saved width of the assem
instructions column in context.

\begin{tcblisting}{listing only}
every assem/.style={...}
assem <ioid>/.style={...}

code label position=<above|inline|left|none> % (no default, initially 'above')
code label/.code 2 args={...} % (no default, initially prints "#1:" if #1 is not empty)
  % When 'code label position' is not set to 'none', this code will be executed for
  % every assembly instruction, with #1 set to the location label and #2 set to the ioid,
  % to typeset the code label.

show eiids comment=<true|false> % (default: true, initially true (assem) or false (full/events))
eiids comment/.code={...} % (no default, initially "\hfill//#1")
  % This code is used to typeset, at the end of the assembly line, the
  % eiids (#1) associated with the instruction.
eiids comment <ioid>/.code={...}

assem <ioid>/.style={
  % Prepend text to the assembly code
  /tikz/execute at begin node={...},
  % Append text to the assembly code (between the assembly code and the eiids comment)
  /tikz/execute at end node={...}
}
\end{tcblisting}


\begin{tcblisting}{listing only}
every events/.style={...} % #1 is set to ioid
events <ioid>/.style={...}
eiids order={<eiid list>}
  % For example: events 1-2/.style={eiids order={d0,d1}}
  % This key changes the order in which events are typeset for mixed-size
  % memory accesses. This key also affects the eiids comment.
  % This key can be used to totally change the events. For example,
  % adding the key 'd/.style={event=d0..1, alias=d0, alias=d1, node contents={R x=0x12}}'
  % and then setting 'events 1-2/.style={eiids order={d}}' will typeset
  % both events (d0, d1) in a single line.

every event/.style={...} % #1 is set to eiid
event <eiid>/.style={...}

show event label=<true|false> % (default: true, initially true)

every event label/.style={...} % #1 is set to eiid
event label <eiid>/.style={...}

event label/.code={...} % (no default, initially "#1:")
  % Executed for every event, with #1 set to the event's eiid, to typeset a label.
every init/.style={...} % #1 is the eiid
event init-<eiid>/.style={...}
init right=<eiid>
init left=<eiid>
init above right=<eiid>
init below right=<eiid>
init above left=<eiid>
init below left=<eiid>
every events box/.style={...} % #1 is set to ioid
events box <ioid>/.style={...}
\end{tcblisting}

Presets for nicer mixed size events:
\begin{tcblisting}{listing only}
boxed events=<color> % (default: black!10, initially not set)
  % You should probably set the text width of events to something
  % fixed:
  %   every event/.style={text width={width("W x=2")}},
  %   every event label/.style={text width={width("a")}},
\end{tcblisting}

\begin{tcblisting}{listing only}
every relation/.style={...}

every event relations/.style={...}
every instruction relations/.style={...}
label pos=<fraction> % (no default, initially 0.5)
label text=<text> % (no default, initially the edge name (e.g. 'po'))
every label/.style={...}
/tikz/<edge name>=<text> % (default: <edge name>)
  % The possible values of <edge name> depend on the loaded architecture.
  % The following are part of all architectures: po, co, rf, fr, ctrl,
  % ctrl+addr, addr, data
every <edge name>/.style={...}
every <edge name> label/.style={...}
hide <edge name>
hide edges={<edge name>, <edge name>, ...} % (no default)
hide % e.g. '(1-4) isb (1-7)/.style=hide'
vertical align=<anchor> % (no default, initially \tikztostart of the first edge on which the style was
                        % applied, in the current scope)
\end{tcblisting}

To change the edge color one can use the option:
\begin{tcblisting}{listing only}
every <edge name>/.style={<color>}
\end{tcblisting}
or use the \lstinline[language={[LaTeX]TeX},basicstyle=\footnotesize\ttfamily]|\colorlet| macro like this:
\begin{tcblisting}{listing only}
\colorlet{<edge name> color}{<color>}
\end{tcblisting}

\begin{tcblisting}{listing only}
(<node 1>) <edge name> (<node 2>)/.style={...}
  % where nodes can be ioids or eiids, changes this specific edge.
\end{tcblisting}
The above only works on existing edges, see \S\ref{sec:patching} for adding edges.

\begin{tcblisting}{listing only}
mem access/<R* or W*>/.code={...} % (no default, initially something reasonable)
  % e.g.: mem access/Wrel/.code={write-release}
  % will produce: "a:write-release x=1"
\end{tcblisting}

By default, only in the \lstinline|events| kind, edges are curved using predefined
styles, based on the \lstinline|{<dtid>,<drow>}| distance of the edge.
For example, in the minimal example at the beginning, the edge
\lstinline|(e) fr (a)| has the distance \lstinline|{-1,-1}|, and so, the predefined
style \lstinline|edge distance {-1,-1}| is applied to the edge.
The style \lstinline|edge distance {<dtid>,<drow>}| uses the keys \lstinline|in|,
\lstinline|out|, \lstinline|bend|, \lstinline|looseness|, \lstinline|label pos| and such like
to curve the edge, in what is mostly a satisfying way.
This does not work very well for mixed-size tests.

\begin{tcblisting}{listing only}
disable edge routing
enable edge routing
edge distance {<dtid>,<drow>}/.style={...}
% Below, nodes can be ioids or eiids:
from (<node>)/.disable routing                     % disable routing for all edges going out of <node>
to (<node>)/.disable routing                       % disable routing for all edges coming into <node>
(<node>)/.disable routing                          % disable all routing for <node>
(<node 1>) <edge name> (<node 2>)/.disable routing % disable routing for this specific edge
<edge name>/.disable routing                       % disable all routing for <edge name>
  % The last two can also be achived like this:
  %   (<node 1>) <edge name> (<node 2>)/.style={disable edge routing}
  %   every <edge name>/.style={disable edge routing}
\end{tcblisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Additional options for \texttt{\textbackslash inputlitmustable}}

\begin{tcblisting}{listing only}
litmus name={...}   % (initially loaded from the .state.tex file)
architecture={...}  % (initially loaded from the .state.tex file)
initial state={...} % (initially loaded from the .state.tex file)
final state={...}   % (initially loaded from the .state.tex file)

initial state prefix={...}  % (initially "Initial state:~")
final state prefix={...}    % (initially "Final state:~")

% The following options set 'final state prefix', and in addition, if
% the argument is not empty, set 'final state' to the argument:
final state allowed={<state>}               % "Allowed:~"
final state allowed not observed={<state>}  % "Allowed (not observed):~"
final state forbidden={<state>}             % "Forbidden:~"
final state forbidden observed={<state>}    % "Forbidden (observed):~"

state prefix font={...} % (initially empty)

every table header/.style={...}
every box/.style={...}
every state/.style={...}
every initial state/.style={...}
every final state/.style={...}
every threads box/.style={...}

every border between threads/.style={...}
every thread headers border/.style={...}

every final state allowed/.style={...}
every final state forbidden/.style={...}
every final state unknown/.style={...}

every code line/.style={...}
every odd code line/.style={...}
every even code line/.style={...}
  % In all the above styles, #1 is set to the line number.
every code line <i>/.style={...} % where <i> is a line number (1 for the first line)

table construction/.style={...}
  % (initially "{table header={above=1pt of threads box, anchor=base},
  %              initial state box={below=2pt of threads box},
  %              final state box={below=of initial state box}})
  % Redefine this style to construct the table in a different way.
\end{tcblisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Patching memory accesses}\label{sec:patching}
One can always brute force it using \lstinline|node contents|:
\begin{tcblisting}{listing only}
event <eiid>/.style={node contents={<text>}}
\end{tcblisting}
A better way is to use one or several of the following \lstinline|event <eiid>/.change <...>| handlers.
Those take an argument of the form \lstinline|from <old> to <new>|, where \lstinline|<old>| is
the value specified in the \verb|.tikz| file and \lstinline|<new>| is the value you want
it to change to. If the \lstinline|<old>| value does not match the \verb|.tikz| value,
or the \lstinline|<eiid>| does not exist, a compilation error is raised.
\begin{tcblisting}{listing only}
event <eiid>/.change addr=from x to y
event <eiid>/.change offset=from 0 to 4
event <eiid>/.change size=from 4 to 8
event <eiid>/.change footprint=from x+0/4 to y+4/8 % do all the above in one go
event <eiid>/.change value=from 1 to 2
event <eiid>/.change mem access={from x+0/4=1 to y+4/8=2} % the { } are mandatory
event <eiid>/.change eiid=to <new eiid> % this one does not have a 'from' part

check value/.code={}  % disables the old value check
check exists/.code={} % disables the existence check
\end{tcblisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Adding missing edges:
\begin{tcblisting}{listing only}
% for rf/co/fr we want the edge to be between two eiids (maybe from different threads):
(<eiid 1>) <edge name> (<eiid 2>)/.add events edge={...}
  % this works even when <eiid 1> is an 'init-<eiid>' and even if the init node does
  % not exist, in which case the init node will be added too.

% for all the other edges we want the edge to be between two ioids (from the same thread):
(<ioid 1>) <edge name> (<ioid 2>)/.add instructions edge={...}
\end{tcblisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global options}\label{sec:global}

In addition to the options from the previous sections, one can also use:
\begin{tcblisting}{listing only}
every litmus/.style={...}
every full litmus/.style={...}
every events litmus/.style={...}
every assem litmus/.style={...}
every litmus table/.style={...}
every litmus picture/.style=

is assem litmus/.if true=then {<true>}[ else {<false>}]
is assem litmus/.if false=then {<true>}[ else {<false>}]
is events litmus/.if true=then {<true>}[ else {<false>}]
is events litmus/.if false=then {<true>}[ else {<false>}]
  % It only makes sense to use these inside a style like 'every litmus'
\end{tcblisting}

For example, this document uses this:
\begin{tcblisting}{listing only}
\newif\ifdrawbox
\tikzset{
  draw box/.is if flag=drawbox, draw box,
  /litmus/every litmus/.style={
    AArch64,
    % Add a dashed line to all the litmus pictures that follow, showing their bounding box
    /tikz/draw box/.if true=then {
      execute at end scope={
        \draw[dashed, thin, opacity=0.2]
          (current bounding box.south west) rectangle (current bounding box.north east);
      }
    },
    % Don't include the edges (and their labels) when calculating the
    % bounding box (makes the pictures very tight)
    every relation/.append style=overlay,
    % DEBUG:
    %every node/.style=draw,
    %code label position=left, code label/.code 2 args={{\color{black}\tiny ##2}},
  },
}
\end{tcblisting}

\newif\ifdrawbox
\tikzset{
  draw box/.is if flag=drawbox, draw box,
  /litmus/every litmus/.style={
    AArch64,
    % Add a dashed line to all the litmus pictures, showing their bounding box
    /tikz/draw box/.if true=then {
      execute at end scope={
        \draw[dashed, thin, opacity=0.2]
          (current bounding box.south west) rectangle (current bounding box.north east);
      }
    },
    % Don't include the edges (and their labels) when calculating the
    % bounding box (makes the pictures very tight)
    every relation/.append style=overlay,
    % DEBUG:
    %every node/.style=draw,
    %code label position=left, code label/.code 2 args={{\color{black}\tiny ##2}},
  },
}

The assembly code is typeset using \lstinline+\assem|<code>|+.
Initially \lstinline+\assem+ is defined to be \lstinline+\verb+.
One should take care when redefining \lstinline+\assem+ as it needs
to handle unescaped input. In addition, for technical reasons, line
numbers, code labels and the eiids comments (when enabled) can not be
typeset using \lstinline+\verb+. Instead, initially, they are typeset
using \lstinline+\ttfamily+.

\verb|litmus.listings| is an extension to the \verb|litmus| \TikZ{} library
that makes it easier to redefine \lstinline+\assem+ to use the listings package.
After loading the library the \TikZ{} key \lstinline+use listing={<opts>}+
will redefine \lstinline+\assem+ to use \lstinline+\lstinline[<opts>]+.
\lstinline+<opts>+ can be changed later using the \TikZ{} key \lstinline+listing options={<opts>}+ (or \lstinline+listing options/.append={<opts>}+ or \lstinline+listing options/.prefix={<opts>}+).
In addition, \lstinline+use listing+ will cause code labels
and the eiids comments to be typeset using the same macro. This document
loads \TikZ{} like this:
\begin{tcblisting}{listing only}
\usepackage{tikz}
\usetikzlibrary{litmus, litmus.listings}
\litmusset{use listing={style=litmus, basicstyle=\footnotesize\ttfamily}}
\end{tcblisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples}\label{sec:examples}

A few practical tips before the examples:
\begin{itemize}\itemsep0ex
  \item empty lines between the square brackets will produce cryptic compilation errors;
  \item it can be useful to use \lstinline|.append style| instead of \lstinline|.style|;
  \item it is always safe to enclose the right hand side of = in curly braces,
  but if the right hand side expression contains ``='' or ``,'' it must be enclosed in curly braces;
  \item do not edit the .tikz and .states.tex files generated by rmem, instead
  use \lstinline|<options>| to patch them;
  \item code labels with special characters (\char`_, \$, etc.) will cause compilation
  errors with the default \lstinline|\assem| macro; this can be fixed by using the
  listings package as described in \S\ref{sec:global};
  \item if the document has a large number of litmus diagrams you probably
  want to use \TikZ{}'s externalization library (see the PGF manual) to
  speed up compilation.
\end{itemize}

\subsection{A simple events example}
\begin{tcblisting}{sidebyside, lefthand width=9cm}
% Example 1.
\inputlitmuspicture{events}{A64/MP+dmb.sy+ctrl}
\end{tcblisting}


\subsection{A simple assem example}
\begin{tcblisting}{sidebyside, lefthand width=9cm}
% Example 2.
\inputlitmuspicture[%
  every thread header/.style={inner sep=0},
  header to instructions distance=0.5ex,
  threads distance=1pt,
  compute assem text width=example2,
  every assem/.append style={
    text width=computedwidth + 1em,
  },
]{assem}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}


\subsection{A simple full example}
\begin{tcblisting}{sidebyside, lefthand width=8cm}
% Example 3.
\inputlitmuspicture[%
  code label position=left,
  add row after={1-3}{},
% edge routing:
  hide edges={po, isb},
  (1-4) ctrl (1-7)/.style={label text=ctrl+isb},
  (c) rf (d)/.style={label pos=0.2, out=25, in=-123,
                        looseness=1.2},
  (c) co (e)/.style={bend right=8, label pos=0.3},
  % edges between instructions will automatically
  % appear to be on a straight line. For other edges
  % we have to do it by hand by using
  % 'vertical align=<node>' as below. The edge will
  % be aligned with '<node>.center'. The
  % auto-aligned edges will align with the node from
  % which the first edge exits. In this case we have
  % hidden the first two edges ('hide edges' above),
  % so the first node is '1-4' (the ioid 'ctrl'
  % exits from).
  (d) fr (e)/.style={vertical align=1-4},
  (e) rf (f)/.style={vertical align=1-4},
  (h) fr (a)/.style={out=-170, in=-130,
                      looseness=1.5, swap},
]{full}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}

\subsection{Assem table examples}
\begin{tcblisting}{sidebyside, lefthand width=9.6cm}
% Example 4a.
\tikzset{draw box=false}
\inputlitmustable[%
  code label position=inline,
  compute assem text width=example4a,
  every assem/.append style={
    inner xsep=1pt,
    text width=computedwidth + 1.5em,
  },
  every odd code line/.style={fill=black!10},
  % Show line numbers:
  every code line/.style={
    append after command={
      node[anchor=west, at=(\tikzlastnode.west), inner xsep=1pt
        % Alternative (outside the table): anchor=east
      ] {\scriptsize\texttt{#1.}}
    },
  },
  thread 0/.style={
    % Leave some room for the line number
    execute at begin node={\phantom{\scriptsize\texttt{0.}}},
    add row after={0-5}{}, % 'assem 0-5-1'
    add row after={0-5}{\ttfamily//comment}, % 'assem 0-5-2'
  },
  % Alternative line numbers:
  % every assem/.append style={
  %   execute at begin node={%
  %     {\scriptsize\texttt{\the\pgfmatrixcurrentrow.}}%
  %   },
  % },
]{assem}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}

\begin{tcblisting}{sidebyside, lefthand width=9.6cm}
% Example 4b.
\tikzset{draw box=false}
\inputlitmustable[%
  compute assem text width=example4b,
  every assem/.append style={
    inner xsep=1pt,
    text width=computedwidth + 1.5em,
  },
  thread 1/.style={
    % Make sure Thread 1 and 2 have the same width
    every assem/.append style={
      text width={max(computedwidth,
          computedwidthofthread("example4b",2)) + 1.5em},
    },
  },
  thread 2/.style={
    % Place Thread 2 below Thread 1 (using Thread 1's chain alias
    % "threads-2")
    every instructions/.style={below=4ex of threads-2.south west},
    % Make sure Thread 1 and 2 have the same width
    every assem/.append style={
      text width={max(computedwidth,
          computedwidthofthread("example4b",1)) + 1.5em},
    },
  },
  execute at end scope={
    % Draw the vertical lines below and above Thread 2's header
    \draw (threads-3.north west) -- (threads-3.north east);
    \draw (thread 2 header.north -| threads-3.west)
      -- (thread 2 header.north -| threads-3.east);
  },
]{assem}{A64/WRC+addrs}
\end{tcblisting}

\subsection{A full table example}
\begin{tcblisting}{}
% Example 5.
\tikzset{draw box=false}
\inputlitmustable[%
  final state allowed,
  architecture=\color{red}ARMv8,
  % change the borders:
  every box/.style={draw=blue!70!black},
  every thread headers border/.style={draw=blue!70!black},
  every border between threads/.style={draw=blue!70!black},
  % reorder the boxes:
  table construction/.style={
    initial state box={above=of threads box},
    table header={above=1pt of initial state box},
    final state box={below=of threads box},
  },
  every assem/.append style={inner xsep=1pt},
% edge routing:
  (c) rf (d)/.style={out=35, in=172, out looseness=2, in looseness=2.2, label pos=0.3},
  (e) fr (a)/.style={out=-160, in=-135, looseness=1.8, label pos=0.9},
]{full}{A64/MP+dmb.sy+ctrl}
\end{tcblisting}

\subsection{A table and diagram example}
\begingroup
\tikzset{draw box=false}
\begin{tcblisting}{}
% Example 6.
\litmusset{
  every litmus/.append style={
    thread 0/.append style={every thread header/.style={alias=thread-0}},
    baseline=(thread-0.base),
  },
}
\inputlitmustable[%
  compute assem text width=example6a,
  every assem/.append style={
    inner xsep=1pt,
    text width=computedwidth + 1em,
  },
]{assem}{A64/MP+dmb.sy+ctrl}
\hspace{1em}
\inputlitmuspicture{events}{A64/MP+dmb.sy+ctrl}
\end{tcblisting}
\endgroup

The above is nice as an inline diagram that has no caption.
If you use this inside a figure environment with a caption and you want
to remove the litmus name and architecture from on top of the table, add
this to the options:
\begin{tcblisting}{listing only}
table construction/.style={
  initial state box={below=2pt of threads box},
  final state box={below=of initial state box},
},
\end{tcblisting}

\subsection{Patching edges and values example}
\begin{tcblisting}{sidebyside, lefthand width=10cm}
% Example 7.
\inputlitmuspicture[%
% remove bad edges:
  (c) fr (b)/.style=hide,
  (init-c) rf (c)/.style=hide,
  event init-c/.style=hide,
% add missing edges and values:
  (b) rf (c)/.add events edge,
  event a/.change value=from 1 to 2,
  event c/.change value=from 0 to 1,
  event d/.change value=from 1 to 2,
]{events}{A64/LB+addr+data}
\end{tcblisting}


\subsection{A simple events example}
\begin{tcblisting}{sidebyside, lefthand width=11cm}
% Example 8.
\inputlitmuspicture[%
  hide edges={po, isb},
  (1-4) ctrl (1-7)/.style={label text=ctrl+isb},
  (d) fr (e)/.style={vertical align=1-4},
  (e) rf (f)/.style={vertical align=1-4},
  (h) fr (a)/.style=swap,
]{events}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}


\subsection{A full example with boxed events}
\begin{tcblisting}{}
% Example 9.
\inputlitmuspicture[%
  boxed events,% adds the gray boxes around the events
  every event/.style={text width={width("W y=2")}},
  every event label/.style={text width={width("a:")}},
  every thread header/.style={inner sep=0, below delimiter=|},
  header to instructions distance=1ex,
  every instructions/.style={column sep=0},
  add row after={1-3}{},
  assem 1-5/.style={overlay},
% edge routing:
  hide edges={po, isb},
  (1-4) ctrl (1-7)/.style={label text=ctrl+isb},
  (c) rf (d)/.style={label pos=0.2, out=25, in=-125, looseness=1.2},
  (c) co (e)/.style={bend right=8, label pos=0.3},
  (d) fr (e)/.style={vertical align=1-4},
  (e) rf (f)/.style={vertical align=1-4},
  (h) fr (a)/.style={out=-170, in=-130, looseness=1.7, swap},
]{full}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}


\subsection{A mixed-size example with boxed events}
\begin{tcblisting}{}
% Example 10.
\tikzset{draw box=false}
\inputlitmuspicture[%
  mixed-size,
  boxed events,
  every event/.style={text width={width("W x[2]=0x22")}},
  every event label/.style={text width={width("e0:")}},
  threads distance=5em,
  thread 0/.append style={every thread header/.style={alias=thread-0}},
  baseline=(thread-0.base),
  every rf label/.style={anchor=south, sloped},
  event e0/.change eiid=to {e\textsubscript{0}},
  event e1/.change eiid=to {e\textsubscript{1}},
  events 1-2/.style={eiids order={e0,e1}},
% edge routing:
  (c) rf (e0)/.style={label pos=0.65},
  (c) rf (d)/.style={out=0, in=180},
  event init-e1/.style={left=4em of e1},
  (init-e1) rf (e1)/.style={every rf label/.style={anchor=north, sloped}},
  (e1) fr (a)/.style={out=-165,in=-150,looseness=2.2},
]{events}{A64/MP+dmbsy+misaligned2+1}
\hspace{1em}
\inputlitmustable[%
  mixed-size,
  thread 0/.append style={every thread header/.style={alias=thread-0}},
  baseline=(thread-0.base),
  compute assem text width=example10b,
  every assem/.append style={
    inner xsep=1pt,
    text width=computedwidth,
  },
  events 1-2/.style={eiids order={e0,e1}},
]{assem}{A64/MP+dmbsy+misaligned2+1}
\end{tcblisting}

\subsection{A crazy full example to show more options}
\begin{tcblisting}{}
% Example 11.
\inputlitmuspicture[%
  threads distance=5em,
  % every node/.style=draw, % darw a box around all nodes
  every instructions/.style={column sep=0, row 1/.style={every assem/.append style={text height=2ex}}},
  add row after={1-3}{},
  % modify all the assembly nodes:
  every assem/.append style={fill=teal, opacity=0.2, text opacity=1,
    inner xsep=1pt,
    minimum height=2ex,
  },
  every thread/.style={thread header text={- #1 -}},
  % modify the assembly node of specific instruction:
  assem 0-2/.style={fill=red},
  % modify the label of assembly instructions:
  code label/.code 2 args={%
    \if\relax\detokenize{#1}\relax%
      % if the location has no label we can use the ioid (#2)
      {\tiny #2:}%
    \else%
      % the location has a label (#1)
      \texttt{#1:}%
    \fi%
  },
  code label position=left,
  % modify all events:
  every event/.style={fill=lime, opacity=0.5, text opacity=1, inner sep=1pt},
  % modify specific event:
  event a/.style={fill=red},
  event label/.code={{\color{black}#1|~}}, % or, remove the label: 'event label/.code='
  every event relations/.style={on background layer},
  every rf label/.style={anchor=south, sloped},
  every dmb/.style={magenta}, % alternative: \colorlet{dmb color}{magenta}
% edge routing:
  hide po,
  every init/.style={node distance=1em, right=of #1},
  (1-4) isb (1-7)/.style=hide,
  (1-4) ctrl (1-7)/.style={label text=ctrl+isb},
  (c) rf (d)/.style={label pos=0.2, out=20, in=-130, looseness=1.1},
  (c) co (e)/.style={bend right=5, label pos=0.3},
  (d) fr (e)/.style={vertical align=1-4},
  (e) rf (f)/.style={vertical align=1-4, every rf label/.style={}},
  (h) fr (a)/.style={out=-150, in=-145, swap},
  (init-h) rf (h)/.style={label text=\tiny rf},
]{full}{A64/MP+dmb.sy+fri-rfi-ctrlisb}
\end{tcblisting}


\subsection{A simple hand written events example}
\begin{tcblisting}{sidebyside, lefthand width=10.2cm}
% Example 12a.
\begin{tikzpicture}[/litmus/append to tikz path search,kind=events]
  % Thread 0
  \node[simple instructions] {
    % <eiid>:<text> \\
    a:R x=1 \\
    b:W y=1 \\
  };
  \draw[vertical align] (a) edge[addr] (b);

  % Thread 1
  \node[simple instructions] {
    c:R y=1 \\
    d:W x=1 \\
    !\node[text width=8em] {starting a cell with `!' %
                            turns off the simple syntax}; \\
  };
  \draw[vertical align] (c) edge[data] (d);

  \draw (d) edge[rf] (a)
        (b) edge[rf] (c);
\end{tikzpicture}
\end{tcblisting}

The above example is very easy to write but it hides some of the underlying \TikZ{}
elements. This makes it harder to customise them. The following example
exposes those elements.

\begin{tcblisting}{sidebyside, lefthand width=10.2cm}
% Example 12b.
\begin{tikzpicture}[/litmus/append to tikz path search,kind=events]
  \node[instructions=0] (thread 0) {
    \node[event=a] {R x=1}; \\
    \node[event=b] {W y=1}; \\
  };
  \draw[vertical align] (a) edge[addr] (b);
  \node[thread header, above=of thread 0] {Thread 0};

  \node[instructions=1] (thread 1) {
    \node[event=c] {R y=1}; \\
    \node[event=d] {W x=1}; \\
  };
  \draw[vertical align] (c) edge[data] (d);
  \node[thread header, above=of thread 1] {Thread 1};

  \draw (d) edge[rf] (a)
        (b) edge[rf] (c);
\end{tikzpicture}
\end{tcblisting}


\subsection{A simple hand written full example}
\begin{tcblisting}{}
% Example 13a.
\begin{tikzpicture}[/litmus/append to tikz path search,kind=full]
  % Thread 0
  \node[simple instructions] {
    % |<assembly>| & <eiid>:<text> \\
    |MOV W0,#1  |            \\
    |STR W0,[X1]|  & a:W x=1 \\
    |DMB SY     |            \\
    |MOV W2,#1  |            \\
    |STR W2,[X3]|  & c:W y=1 \\
  };
  \draw[vertical align] (a) edge[dmb] (c);

  % Thread 1
  \node[simple instructions] {
    |LDR W0,[X1] | & d:R y=1 \\
    |CBNZ W0,LC00|           \\
    |LC00:       |           \\
    |LDR W2,[X3] | & e:R x=0 \\
  };
  \draw[vertical align] (d) edge[ctrl] (e);

  \draw (c) edge[rf, out=35, in=172, out looseness=2, in looseness=2.2, label pos=0.3] (d)
        node[init=e] {} edge[rf] (e)
        (e) edge[fr, out=-160, in=-135, looseness=1.8, label pos=0.9] (a);
\end{tikzpicture}
\end{tcblisting}

The above example is very easy to write but it hides some of the underlying \TikZ{}
elements. This makes it harder to customise them. The following example
exposes those elements.

\begin{tcblisting}{}
% Example 13b.
\lstset{language=AArch64, style=litmus, basicstyle=\footnotesize\ttfamily}%
\begin{tikzpicture}[/litmus/append to tikz path search,kind=full]
  \node[instructions=0] (thread 0) {
    \node[assem] {\lstinline|MOV W0,#1  |};                            \\
    \node[assem] {\lstinline|STR W0,[X1]|};  & \node[event=a] {W x=1}; \\
    \node[assem] {\lstinline|DMB SY     |};                            \\
    \node[assem] {\lstinline|MOV W2,#1  |};                            \\
    \node[assem] {\lstinline|STR W2,[X3]|};  & \node[event=c] {W y=1}; \\
  };
  \draw[vertical align] (a) edge[dmb] (c);
  \node[thread header, above=of thread 0] {Thread 0};

  \node[instructions=1] (thread 1) {
    \node[assem] {\lstinline|LDR W0,[X1] |}; & \node[event=d] {R y=1}; \\
    \node[assem] {\lstinline|CBNZ W0,LC00|};                           \\
    \node[assem] {\lstinline|LC00:       |};                           \\
    \node[assem] {\lstinline|LDR W2,[X3] |}; & \node[event=e] {R x=0}; \\
  };
  \draw[vertical align] (d) edge[ctrl] (e);
  \node[thread header, above=of thread 1] {Thread 1};

  \draw (c) edge[rf, out=35, in=172, out looseness=2, in looseness=2.2, label pos=0.3] (d)
        node[init=e] {} edge[rf] (e)
        (e) edge[fr, out=-160, in=-135, looseness=1.8, label pos=0.9] (a);
\end{tikzpicture}
\end{tcblisting}

\subsection{Scaling}
The diagrams scale with the text automatically:
\def\one{1}%
\begin{tcblisting}{}
% Example 14a.
\foreach \s [count=\c] in {\tiny,\normalsize,\Huge} {%
  \s%
  \ifx\c\one\else\hfill\fi%
  \inputlitmuspicture{events}{A64/MP+dmb.sy+ctrl}%
}
\end{tcblisting}

\vspace{1ex}
Notice that in \S\ref{sec:global} we globally set \lstinline|basicstyle=\footnotesize\ttfamily|.
Therefore, the assembly text will not scale with the surrounding text.
Instead, we have to explicitly reset this key with the appropriate size
as shown below.

\begin{tcblisting}{}
% Example 14b.
\foreach \s/\t [count=\c] in {\scriptsize/\tiny,\normalsize/\footnotesize,\huge/\Large} {%
  \s%
  \ifx\c\one\else\hfill\fi%
  \inputlitmuspicture[%
    listing options/.append={,basicstyle=\t\ttfamily},% <-- SET ASSEM SIZE
    every thread header/.style={inner sep=0},
    header to instructions distance=0.5ex,
    threads distance=1pt,
  ]{assem}{A64/MP+dmb.sy+fri-rfi-ctrlisb}%
}
\end{tcblisting}

Alternatively, you can simply use \lstinline+\scalebox{<factor>}{<litmus>}+:
\begin{tcblisting}{}
% Example 14c.
\foreach \s [count=\c] in {0.5,1,2} {%
  \ifx\c\one\else\hfill\fi%
  \scalebox{\s}{\inputlitmuspicture{events}{A64/MP+dmb.sy+ctrl}}%
}

\vspace{3ex}
\foreach \s [count=\c] in {0.5,1,2} {%
  \ifx\c\one\else\hfill\fi%
  \scalebox{\s}{%
    \inputlitmuspicture[%
      every thread header/.style={inner sep=0},
      header to instructions distance=0.5ex,
      threads distance=1pt,
    ]{assem}{A64/MP+dmb.sy+fri-rfi-ctrlisb}%
  }%
}
\end{tcblisting}

\end{document}
